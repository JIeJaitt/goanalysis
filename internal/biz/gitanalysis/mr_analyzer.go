package gitanalysis

import (
	"context"
	"encoding/json"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"regexp"
	"strings"
	"sync"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/sourcegraph/conc/pool"
	"github.com/toheart/goanalysis/internal/biz/gitanalysis/dos"
	"github.com/toheart/goanalysis/internal/conf"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// 定义一个结构体来存储文件处理结果
type fileProcessResult struct {
	Filename   string
	ChangeType dos.ChangeType
	Functions  []*dos.Function
	Error      error
}

type fileProcessTask struct {
	ProjectID  int
	Path       string
	Ref        string
	ChangeType dos.ChangeType
	Filename   string
	Content    string // 如果是修改的文件，则需要提供修改后的内容
}

// MRAnalyzer GitLab MR分析器
type MRAnalyzer struct {
	sync.Mutex
	conf   *conf.Biz
	llm    *LLMAnalyzer
	logger *log.Helper
	gCli   *gitlab.Client
}

// NewMRAnalyzer 创建新的MR分析器
func NewMRAnalyzer(conf *conf.Biz, gitlabClient *gitlab.Client) (*MRAnalyzer, error) {
	log.Infof("gitlabURL: %s", conf.Gitlab.Url)
	// 创建GitLab客户端
	llm, err := NewLLMAnalyzer(
		conf.Openai.ApiKey,
		conf.Openai.ApiBase,
		conf.Openai.Model,
	)
	if err != nil {
		return nil, err
	}
	return &MRAnalyzer{
		conf:   conf,
		logger: log.NewHelper(log.With(log.GetLogger(), "module", "gitanalysis")),
		llm:    llm,
		gCli:   gitlabClient,
	}, nil
}

func (a *MRAnalyzer) GetMergeRequest(projectID, mrID int) (*gitlab.MergeRequest, error) {
	mergeRequest, _, err := a.gCli.MergeRequests.GetMergeRequest(projectID, mrID, &gitlab.GetMergeRequestsOptions{})
	if err != nil {
		return nil, err
	}
	return mergeRequest, nil
}

// isGeneratedFile 判断文件是否为自动生成的文件
func (a *MRAnalyzer) isGeneratedFile(content string) bool {
	// 检查文件开头的几行是否包含常见的自动生成文件标记
	lines := strings.Split(content, "\n")

	// 只检查前15行，通常自动生成文件的标记都在文件开头
	checkLineCount := 15
	if len(lines) < checkLineCount {
		checkLineCount = len(lines)
	}

	// 常见的自动生成文件的标记
	generatedMarkers := []string{
		"Code generated",
		"DO NOT EDIT",
		"GENERATED",
		"Auto-generated",
		"Automatically generated",
		"This file was auto-generated",
		"This code was generated",
		"generated by",
		"This is a generated file",
		"NOTE: This file is auto generated",
	}

	// 检查前几行是否包含自动生成标记
	for i := 0; i < checkLineCount; i++ {
		for _, marker := range generatedMarkers {
			if strings.Contains(strings.ToUpper(lines[i]), strings.ToUpper(marker)) {
				return true
			}
		}
	}

	// 检查protobuf生成文件的特征
	protoRegex := regexp.MustCompile(`(?i)(proto|grpc)\..*RegisterService`)
	if protoRegex.MatchString(content) {
		return true
	}

	// 检查是否包含特定的生成工具注释
	toolsRegex := regexp.MustCompile(`(?i)generated.*(by|with|using).*\b(protoc|swagger|openapi|grpc|pb|thrift|avro|jooq|gorm|sqlc)\b`)
	return toolsRegex.MatchString(content)
}

// filterFileByName 通过文件名判断是否为自动生成的文件
func (a *MRAnalyzer) filterFileByName(filename string) bool {
	// 检查常见的生成文件命名模式
	patterns := []string{
		`\.pb\.go$`,             // protobuf生成的文件
		`\.gen\.go$`,            // 通用生成文件后缀
		`_gen\.go$`,             // 另一种通用生成文件后缀
		`_generated\.go$`,       // 包含generated的文件
		`mock_.*\.go$`,          // mock文件
		`.*\.generated\.go$`,    // 另一种generated文件格式
		`.*-gen\.go$`,           // 使用连字符的生成文件
		`swagger\.json$`,        // swagger生成文件
		`openapi\.json$`,        // openapi文件
		`.*_string\.go$`,        // stringer生成的文件
		`zz_generated\..*\.go$`, // k8s样式的生成文件
		`.*_test\.go$`,          // 测试文件
	}

	for _, pattern := range patterns {
		matched, _ := regexp.MatchString(pattern, filename)
		if matched {
			return true
		}
	}

	return false
}

func (a *MRAnalyzer) fetchModifiedFile(task fileProcessTask) fileProcessResult {
	if task.Content == "" {
		a.logger.Infof("File %s is empty, skipping", task.Filename)
		return fileProcessResult{
			Filename:   task.Filename,
			ChangeType: task.ChangeType,
		}
	}
	a.logger.Infof("Fetching modified file %s", task.Filename)
	a.Mutex.Lock()
	defer a.Mutex.Unlock()
	result := fileProcessResult{
		Filename:   task.Filename,
		ChangeType: task.ChangeType,
	}

	res, err := a.llm.AnalyzeFile(context.Background(), task.Content)
	if err != nil {
		a.logger.Warnf("Failed to analyze file %s: %v", task.Filename, err)
		result.Error = err
		return result
	}
	for _, r := range res {
		result.Functions = append(result.Functions, r)
	}
	return result
}

// fetchAndProcessFile 异步获取并处理文件内容
func (a *MRAnalyzer) fetchAndProcessFile(task fileProcessTask) fileProcessResult {
	a.logger.Infof("Fetching and processing file %s", task.Filename)
	// 如果是Modified, 使用AI进行分析
	if task.ChangeType == dos.Modified {
		return a.fetchModifiedFile(task)
	}

	result := fileProcessResult{
		Filename:   task.Filename,
		ChangeType: task.ChangeType,
	}

	// 非Modified, 获取文件内容
	content, _, err := a.gCli.RepositoryFiles.GetRawFile(
		task.ProjectID,
		task.Path,
		&gitlab.GetRawFileOptions{
			Ref: gitlab.Ptr(task.Ref),
		},
	)

	if err != nil {
		a.logger.Warnf("Failed to get file content for %s file %s: %v", string(task.ChangeType), task.Path, err)
		result.Error = err
		return result
	}

	if a.isGeneratedFile(string(content)) {
		return result
	}

	// 提取函数
	functions, err := a.extractFunctions(string(content))
	if err != nil {
		a.logger.Warnf("Failed to extract functions from %s file %s: %v", string(task.ChangeType), task.Path, err)
		result.Error = err
		return result
	}

	result.Functions = functions
	return result
}

// AnalyzeMR 分析指定的MR
func (a *MRAnalyzer) AnalyzeMR(projectID, mrID int, autoNotes bool) (*dos.MrAnalysisResult, error) {
	a.logger.Infof("Analyzing MR #%d for project %d", mrID, projectID)
	result := &dos.MrAnalysisResult{
		MergeRequestID: mrID,
		ProjectID:      projectID,
	}

	// 获取MR信息
	mergeRequest, _, err := a.gCli.MergeRequests.GetMergeRequest(projectID, mrID, &gitlab.GetMergeRequestsOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get MR: %w", err)
	}
	a.logger.Infof("MR #%d: %s", mrID, mergeRequest.Title)

	// 收集所有需要处理的任务
	var tasks []fileProcessTask

	// 分页获取MR变更
	page := 1
	for page > 0 {
		mrWithChanges, resp, err := a.gCli.MergeRequests.ListMergeRequestDiffs(projectID, mrID, &gitlab.ListMergeRequestDiffsOptions{
			ListOptions: gitlab.ListOptions{
				Page: page,
			},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to get MR changes: %w", err)
		}
		page = resp.NextPage

		// 处理变更文件
		for _, change := range mrWithChanges {
			// 仅处理Go文件
			if !strings.HasSuffix(change.NewPath, ".go") && !strings.HasSuffix(change.OldPath, ".go") {
				continue
			}
			if a.filterFileByName(change.NewPath) || a.filterFileByName(change.OldPath) {
				continue
			}

			// 确定变更类型和文件名
			var (
				changeType dos.ChangeType
				filename   string
				ref        string
				path       string
				content    string
			)

			switch {
			case change.NewFile:
				changeType = dos.Added
				filename = change.NewPath
				ref = mergeRequest.SourceBranch
				path = change.NewPath
			case change.DeletedFile:
				changeType = dos.Deleted
				filename = change.OldPath
				ref = mergeRequest.TargetBranch
				path = change.OldPath
			default:
				changeType = dos.Modified
				filename = change.NewPath
				content = change.Diff
				a.logger.Infof("Modified file %s detected, need AI analysis", filename)
			}
			result.AffectedFiles = append(result.AffectedFiles, dos.AffectedFile{
				Filename:   filename,
				ChangeType: changeType,
			})
			tasks = append(tasks, fileProcessTask{
				ProjectID:  projectID,
				Path:       path,
				Ref:        ref,
				ChangeType: changeType,
				Filename:   filename,
				Content:    content,
			})
		}
	}

	// 没有需要处理的任务，直接返回结果
	if len(tasks) == 0 {
		return result, nil
	}
	resultCh := make(chan fileProcessResult, 5)
	go func() {
		// 使用pool并发处理所有任务
		p := pool.New().WithMaxGoroutines(10)
		for _, task := range tasks {
			task := task
			p.Go(func() {
				resultCh <- a.fetchAndProcessFile(task)
			})
		}
		p.Wait()
		close(resultCh)
	}()
	// 收集结果
	for res := range resultCh {
		if res.Error != nil {
			a.logger.Errorf("Failed to process file %s: %v", res.Filename, res.Error)
			continue
		}
		if len(res.Functions) > 0 {
			affectedFunction := dos.AffectedFunction{
				Filename:   res.Filename,
				ChangeType: res.ChangeType,
				Functions:  res.Functions,
			}
			result.AffectedFunctions = append(result.AffectedFunctions, affectedFunction)
		}
	}
	a.logger.Infof("prepare to analyze MR: %s", mergeRequest.Title)
	functions, _ := json.Marshal(result.AffectedFunctions)
	// 最后进行Mr审查
	review, err := a.llm.AnalyzeMR(context.Background(), mergeRequest.Title, string(functions))
	if err != nil {
		return nil, fmt.Errorf("failed to analyze MR: %w", err)
	}
	result.Review = review
	if autoNotes {
		err = a.CreateMRNotes(projectID, mrID, result)
		if err != nil {
			a.logger.Errorf("failed to create MR notes: %v", err)
		}
	}
	return result, nil
}

// extractFunctions 从Go源代码中提取函数定义
func (a *MRAnalyzer) extractFunctions(src string) ([]*dos.Function, error) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", src, 0)
	if err != nil {
		return nil, err
	}

	var functions []*dos.Function

	// 遍历AST查找函数声明
	ast.Inspect(f, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.FuncDecl:
			if x.Name != nil {
				// 记录函数名
				funcName := x.Name.Name
				if x.Recv != nil {
					// 这是一个方法，添加接收者类型信息
					if len(x.Recv.List) > 0 {
						recvType := ""
						switch rt := x.Recv.List[0].Type.(type) {
						case *ast.StarExpr:
							if ident, ok := rt.X.(*ast.Ident); ok {
								recvType = "*" + ident.Name
							}
						case *ast.Ident:
							recvType = rt.Name
						}
						if recvType != "" {
							funcName = fmt.Sprintf("%s.%s", recvType, funcName)
						}
					}
				}
				functions = append(functions, &dos.Function{
					FunctionName: funcName,
					IsValid:      true,
					Reason:       "new added function",
					Suggestion:   "",
				})
			}
		}
		return true
	})

	return functions, nil
}

// CreateMRNotes 创建MR的notes
func (a *MRAnalyzer) CreateMRNotes(projectID int, mrID int, result *dos.MrAnalysisResult) error {
	// 创建改动影响面评论
	_, _, err := a.gCli.Notes.CreateMergeRequestNote(projectID, mrID, &gitlab.CreateMergeRequestNoteOptions{
		Body: gitlab.Ptr(result.GetAffectedFilesMd()),
	})
	if err != nil {
		return err
	}
	// 创建AI审查结果评论
	_, _, err = a.gCli.Notes.CreateMergeRequestNote(projectID, mrID, &gitlab.CreateMergeRequestNoteOptions{
		Body: gitlab.Ptr(result.Review),
	})
	return err
}
